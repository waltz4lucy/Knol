1.VI(Visual interface Editor)

☞ 파일처리 및 기능

파일 조작(: CR) 종 료 ZZ (=:wq) 파일이 수정된 경우는 그 파일에 쓰고 종료 수정이 없으면 그대로 종료
:w  변경된 내용을 저장하기
:w!  허가되지 않은 경우에 강제 써넣기
:w <file> 파일 name에 써넣기
:w! <file> 파일 name에 겹쳐 써넣기
:q vi종료하고 Unix프롬프트로 이동
:q! 파일변경 내용을 무시한채 vi종료 및 시스템으로 
:e <file> 새로운 파일의 편집
:e! 변경을 취소하고 재편집
:e+ <file> 최종 행부터 편집 개시
:e +n n 행째부터 편집 개시 
:e # 직전에 편집하고 있던 file을 편집
:e! # 변경 점을 버리고 직전에 편집한 file을 편집
추 가 :r <file>  <file>을 현재의 문서로 read 
:r !<명령어> <명령어> 실행 결과를 read 
:nr <file> n행 아래로 <file>을 read
기 타 :sh 쉘의 임시사용 vi로 복귀시(^d, exit 사용)
:!cmd 명령어 cmd를 실행하고 복귀
:n args 새로운 인수 리스트의 지정
^G 현재의 파일과 행의 표시
:ta tag 커서를 tag에 위치시킴
:f<ESC> 파일은?
다중 파일편 집 $vi A B C D 4개의 파일(A B C D)을 순서대로 작업할 수 있다 
:n 다중화일 편집시 지정한 화일중 현재 파일의 다음 파일로 이동
파일 복구 $vi -r 화일명 시스템이 불시에 꺼졌거나(인터럽 발생시), 저장을 하지 않고 나왔을 때 파일의 변경 내용을 복구함

☞ 커서이동 및 화면처리 기능
화면이동 줄/행단위 n 현재 행으로부터 n번째 행으로 이동한다
+ (n+) 커서를 다음 일행(또는 n행)의 처음으로 이동
- (n-) 커서를 이전 일행(또는 n행)의 처음으로 이동
G 화일의 마지막 행에서 첫번째 문자로 이동
1G 파일의 처음 행의 첫번째 문자로 이동
nG 파일의 n번째 행의 첫번째 문자로 이동
H 화면의 제일위의 행
L 화면의 마지막 행
M 화면의 중앙 행
CR +와 같음
또는 j 다음 행의 같은 칼럼
↑또는 k 앞행의 같은 칼럼
1문자 ^ 공백이 아닌 최초 문자
O 행의 시작
$ 행의 끝
h 또는 → 앞 방향
l 또는 ← 뒤 방향
^H ←(백 스페이스 키)와 같음
nl 지정된 칼럼으로 n 이동
space →(스페이스 바)와 같음
fc (nfc) 다음에 나타나는 문자 c로 이동
Fc (nFc) 이전에 나타나는 문자 c로 이동
tc (ntc) 다음에 나타나는 문자 c 이전으로 이동
Tc (nTc) 이전에 나타나는 문자 c 이전으로 이동
; (n;) 바로 전에 검색한 방법과 같은 방향으로 문자 c로 이동
, (n,) 바로 전에 검색한 방법과 반대 방향으로 문자 c로 이동
단어 w (nw) 다음에 나타나는 단어나 특수 문자의 (시작위치)로 이동
W (nW) 다음에 나타나는 단어(앞)의 공백으로 이동
e (ne) 다음에 나타나는 단어나 특수 문자의 (끝)으로 이동
E (nE) 다음에 나타나는 단어(끝)의 공백으로 이동
b (nb) (이전)에 나타나는 단어나 특수 문자의 (시작위치)로 이동
B nB 이전에 나타나는 단어(앞)의 공백으로 이동
문장/섹션/패러그라프 { or n{ 커서가 있는 패러그라프의 시작 위치로 이동 
} or n} 인접한 이전 패러그라프의 시작 위치로 이동
( 커서가 있는 문장의 처음으로 이동
) 커서가 있는 문장의 끝으로 이동
]] or n]] 인접한 이전 섹션의 시작위치로 이동
[[ or n[[ 인접한 다음 섹션의 시작 위치로 이동
화면단위 ^F n^F 화면을 앞으로 보내기
^B n^B 화면을 뒤로 보내기
^D n^D 반화면 스크롤 다운
^U n^U 반화면 스크롤 업
^Y n^Y 한 행 뒤로 이동
^E n^E 한 행 앞으로 이동
z 커서를 화면의 top으로 이동, 문서가 스크롤됨
z. 커서를 화면의 중간으로 이동, 문서가 스크롤됨
z- 커서를 화면의 bottom으로 이동, 문서가 스크롤됨
^L 현화면을 지우고 다시 출력(refresh)
^R ^L가 →key에 있는 경우 화면을 소거하고 refesh

☞ 편집 기능
삽 입(insert) a 현 커서 위치 다음부터 추가
i 현 커서 위치부터 삽입 시작
A 현재 줄의 마지막에 추가 시작
I 현재 줄의 처음에 추가 시작
o 현재줄 밑에 한줄 첨가
O 현재줄 위에 한줄 첨가
삽입중 수정 ^H 최후의 문자를 지움(백 스페이스)
^W 최후의 단어를 지움
erase 사용자의 소거 문자로 ^H와 같다
kill 사용자의 행 말소 문자. 현 행의 입력을 소거
\ 사용자의 소거 문자나 행 말소 문자를 ESC
ESC 삽입을 종료하고 명령어 모드로 복귀
DEL 인터럽트 삽입 모드를 종료
^D 한 문자 back tab. autointent의 왼쪽 마진을 리셋
^^D 카렛(^)에 이어서 control-d(^D)를 누른다. 
행의 선두에 back tab. autointent의 왼쪽 마진을 리셋하지 않음
O^D 행의 선두에 back tab autointent의 왼쪽 마진을 리셋
^V 프리트 되지 않은 문자를 ESC
행의 결합 J 두 행을 결합하여 한 행으로 만든다 
지우기(delete) 문자 x nx 커서에 위치한 한 문자를 지운다
X nX 커서 이전의 한 문자를 지운다
D 현재 커서 위치에 있는 행의 끝까지 모든 문자를 지운다
d0 행의 시작부분에서 현재 커서 위치 앞 문자까지 지운다
줄 dd ndd 현재 행(또는 n행)을 지운다
dG 현재 행으로부터 파일의 끝까지 모든 행을 지운다 
d1G 현재 행으로부터 파일의 처음 위치까지 모든 행을 지운다 
dnG 현재 행으로부터,상대적으로 n번째 행까지 모든 행을 지운다 
d- 현재 줄과 이전줄 전부를 지운다 
d+ 현재 줄과 다음줄을 지운다
nd- 현재 줄과 이전의 n번째 줄 전부를 지운다
nd+ 현재 줄과 다음의 n번째 줄 전부를 지운다
ddp 현재 줄과 다음 줄을 교환한다
문장/절/구 d) dn) 현재 위치에서 다음 문장의 끝까지 지운다 
d( dn( 이전 문장의 시작 위치에서 커서 이전의 문자까지 지운다
d} dn} 현재 위치에서 다음 paragraph의 끝까지 지운다 
d{ dn{ 이전 paragraph의 시작 위치에서 커서 이전의 문자까지 지운다
d] dn] 현재 위치에서 다음 section의 끝까지 지운다 
d[ dn[ 이전 section의 시작부터 커서 이전의 문자까지 지운다
지정범위까지 dfc dnfc 현재 위치에서 순방향으로 첫번째(n번째) 'c'문자까지 지운다 
dFc dnFc 현재 위치에서 역방향으로 첫번째(n번째) 'c'문자까지 지운다 
dtc dntc 현재 커서 이전에서 순방향으로 첫번째(n번째) 'c'문자까지 지운다 
dTc dnTc 현재 커서 이전에서 역방향으로 첫 번째(n번째) 'c'문자까지 지운다 
d/pat 현재위치에서 순방향으로 탐색하면서 처음 만나는 팬턴(pat)이전까지
d?pat 현재위치에서 역방향으로 탐색하면서 처음 만나는 팬턴(pat)까지
text복구 p 버퍼의 내용(change, delete, yank)을 현재줄 이전에 복구한다
P 버퍼의 내용(change, delete, yank)을 현재줄 다음에 복구한다
문서복구 $vi -r <화일> <화일>은 문제가 생기기전의 화일이름 *시스템이 불시에 꺼졌거나, 저장하지 않고 나왔을때*

☞ 치환 기능
교 체 단어 cw cnw 현재위치에서부터 현재(n번째 다음)단어의 끝까지 변경
cW cnW 현재위치에서부터 현재(n번째 다음)단어의 끝까지 변경
cb cnb 가장 가까운(n번째)이전 단어의 시작부터 현재위치 이전문자 까지변경
cB cnB 가장 가까운(n번째)이전 단어의 시작부터 현재위치 이전문자 까지변경
문장/절/구 c) cn) 현재 위치에서 다음 문장의 끝까지 변경
c( cn( 이전 문장의 시작위치에서 커서 이전의 문자까지 변경
c} cn} 현재 위치에서 다음 paragraph의 끝까지 변경
c{ cn{ 이전 paragraph의 시작위치에서 커서 이전의 문자까지 변경
c]] cn]] 현재 위치에서 다음 section의 끝까지 변경
c[[ cn[[ 이전 section의 시작부터 커서 이전의 문자까지 변경
특정문자까지 cfc cnfc 현재 위치에서 순방향으로 첫번째(n번째) 'c'문자까지 변경
cFc cnFc 현재 위치에서 역방향으로 첫번째(n번째) 'c'문자까지 변경
ctc cntc 현재 커서 이전에서 순방향으로 첫번째(n번째) 'c'문자까지 변경
cTc cnTc 현재 커서 이전에서 역방향으로 첫번째(n번째) 'c'문자까지 변경
검 색 /문자열 문자열을 앞으로 검색
10,20/문자열 10줄에서 20줄까지 문자열 검색
1,$/문자열 처음부터 끝까지 문자열 검색
/문자열/+n 순방향으로 검색된 문자열 다음의 n번째의 줄로 이동
?문자열 문자열을 뒤로 검색하여 이동
?문자열?+n 역방향으로 검색된 문자열 다음의 n번째의 전줄로 이동
n 방금전에 수행한 검색과 같은 방향으로 검색(/)
N 방금 전에 수행한 검색과 반대 으로 검색(?)
콘트롤문자(^)검색하기 :/^M(^V+^M) 컨트롤 문자(^)를 화면에 나타낼 때는 먼저 ^V를 누른 다음 입력하고자 하는 컨트롤 문자를 눌러야 한다
치 환(replacement) :[범위]s/old/new/[cgi] 단 ( . , * [ ^ $ \ / &)은 각각 (\. \* \[ \^ \$ \\ \/ \&)로
[범위] [숫자] 줄 번호
[$] 파일의 끝
[. ] 현재 위치 
[%] 현재화일
[cgi] [c] 변경시 변경여부를 사용자에게 물어 본다 
[g] 한 줄에 나타난 모든 것을 찾아 변경한다
[i] 검색시 대소 문자 구별하지 않는다
:s/old/new/g 현재의 줄에 대해 수행
:10,$s/old/new/g 10줄에서 파일의 끝까지 수행
:g/A/s//B/g 전체화일에서 A를 찾아(g/A)
A를 B로 치환한다 (s//B), s뒤의 //는 text를 다시 쓰지 않아도 되게 한다
이 연산을 한줄에 반복해서 적용한다(/g) 
:g/ABC/s/B/Z/g 전체화일에서 ABC를 찾아(s/B/Z)
ABC중 B 를 Z로 치환한다 (/g)
이 연산을 한줄에 반복해서 적용한다(/g)

☞ 문자열 이동 기능
Mark(마크) 설 정 mc 현 커서의 위치를 'c'로 표시한다 ('c' 는 1문자이며 소문자이다)
이 동 'c 'c'로 표시된 위치로 이동한다
` 'c'로 표시된 줄의 첫 문자로 이동한다
" 지정되었거나, 작업했던 바로 전 줄로 이동
`` 지정되었거나, 작업했던 그 줄의 첫문자로 이동
블럭 저 장/첨 가 :10,20w 화일명 10줄에서 20줄까지 화일명에 저장
:10,20w >> 화일명 10줄에서 20줄까지 화일명에 첨가
삽 입 :10,20r 화일명 10줄에서 20줄까지 화일명에서 읽어와서 현재줄에 삽입
자르기(yank) "a5dd 현재 줄에서 부터 5줄삭제하고, a라는 버퍼에 저장함
복 사 yw 한 단어를 버퍼에 기록시킨다
3yw 3단어를 버퍼에 기록시킨다
y$ 줄의 끝까지 버퍼에 기록시킨다
y) 문자의 끝까지 버퍼에 기록시킨다
yy nyy 현재 (n개의)줄을 버퍼에 기록시킨다 (Y)
"a5Y 현재 줄에서 부터 5줄을 a라는 이름으로 버퍼에 기록
붙히기(put) p 버퍼의 내용을 현재 커서 위치의 오른쪽에 추가시킨다
P 버퍼의 내용을 현재 커서 위치의 왼쪽에 추가시킨다
"ap 버퍼a에 있는 내용을 현재 커서 위치의 왼쪽에 추가시킨다
"np n번 전에 사용한 삭제 명령이나, yank명령에 의해 기록된 버퍼의 내용을 가지고 붙이기 수행
매크로설정(반복되는 작업시) 작 성 :map<키><기능> <키> 는 10자 까지
<기능> 은 100자 까지
*주의) vi의 bug로서 항상 모든 모드에서 매크로가 동작하지는 않는다
해 제 :unmap <키> 매크로 해재
사 용 :map #n <기능> 만약 <키>가 #n - n은 0에서 9까지의 숫자 - 이라면, 그것은 정확한 매크로 키로 설정될 것이다. 
:map #2 :w^M 문서를 작성하다가 기능키 F2를 누르면 :w^M을 실행한다
예 제 :map V :w^M:!ispell -x $^M:e!^M^M (영문철자 검사)
:map #2 :w^M: !cc %^M:e!^M^M (vi에서 기능키 F2로 컴파일)
특수 명령 . 가장 최근 명령 재실행
J 두행을 결합
~ 대문자 소문자 변환
^1 화면을 소거하고 재출력
명령어 기 능 명령어 기 능 commond명령어 기 능 
: ex모드(편집) ^f 앞 방향으로 한 화면 스크롤 :r <file> <file>을 현재의 문서로 read
) 다음 sentence G . . .로 이동(dft는 끝) :r !<명령어> <명령어>실행결과를 read
( 전 sentence ^g 현재줄의 위치를 화면출력 :nr <file> n줄로<file>을 read
} 다음paragraph h 왼쪽으로 한칸 이동 :! 쉘 명령어를 실행
{ 전paragraph H 화면의 첫번째 줄로 이동 :sh 쉘로 나감
]] 다음 section ^h 삽입모드에서 backspace :x 쓰고 나가기
[[ 전 section i 현재 위치 전에 삽입 :wq 쓰고 나가기
0(영) 현 line의 첫번째 문자로 이동 I 줄의 첫번째에 삽입 :11,22w <file> 줄 11과 12사이 내용 저장
$ 현 line의 끝으로 이동 ^i tab (삽입모드에서) :w >> <file> 작업중인 화일<file>에 저장
^ 현 line의 첫번째 문자로 이동 j 아래로 이동 :w! 작업중인 화일 덮어쓰기
+ 다음줄의 첫번째 문자로 이동 k 위로 이동 :q 끝나기(변화는 에러 메시지)
- 전줄의 첫번째 문자로 이동 l 오른쪽으로 이동 :q! 내용변경과 관계없이 종료
spacebar 다음문자 L 화면의 마지막 줄로 이동 :e <file> vi를 나가지 않고<file>편집 
return 다음 줄 ^l refresh :e! 변경을 취소하고 재편집
/ 앞 방향 탐색 m 현위치를 레지스터에 마크 :n 다음화일을 편집
? 뒷 방향 탐색 M 화면의 중간으로 이동 :n <files> 편집하기 위한 화일의 새로운 리스트로서<file>작성
% 서로 쌍을 이루는 (,{,[,-),},}으로 이동 ^m 캐리지 리턴(CR) 
, 마지막f,F,t,T명령의 역방향으로 실행 n 마지막 검색 다시 수행 :e# 직전에 편집하고 있던 <file>작성
; 마지막f,F,t,T명령의 순방향으로 실행 N 마지막 검색 역방향 수행 :args 편집된 화일을 보여줌
. 마지막 명령어 반복 ^n 아래로 이동(명령어 모드) :rew 화일의 맨 위로
` mark한곳으로 이동 o 현재줄 밑에 한줄 첨가 :map m n 매크로설정
' 마크가 있는 줄의 첫번째로 이동 O 현재줄에 한줄 첨가 :map! m n 매크로 설정(삽입 모드)
`` 이전 마크한 곳 or 탐색하기전의 위치 p 현재줄 밑에 넣음 :unmap m 매크로 해제
'' ``의 줄의 처음 P 현재줄 아래로 넣음 :unmap! m 매크로 해제(삽입모드)
~ 대문자↔소문자 변환 ^p 위로 이동(명령어 모드) :ab <1> <2> 약어 설정
" 레지스터 저장 Q 끝내고 ex 실행 :unab <1> 약어 해제
!! 마지막 쉘 명령어 반복 r 현재 문자를 교체 :set <option> set 설정
! send next to commend, replace output(eg !) R 삽입모드가 남을때까지 교체 (즉 ESC를 누를 때까지) :set number 라인번호 붙이기
>> 오른쪽으로 shiftwith만큼 paragraph 이동 ^r refresh(명령어 모드) !} 현재 문단을 지정된 unix 프로그램으로 연결하여 수행 후 결과를 현재 문단과 교체 
<< 왼쪽으로 shiftwith만큼 paragraph 이동 s 교체 
>% 오른쪽으로 (,{,[을 만날때 까지 이동 S 그 행의 모든 문자를 대치 
<% 왼쪽으로 (,{,[을 만날때 까지 이동 t 오른쪽으로 그 문자 바로 전까지 커서 이동 
a 현재문자 다음부터 삽입 모드 T 왼쪽으로 " 
A 현재줄의 끝에 삽입 ^t 다음 shiftwith로 이동 
b 한 단어 뒤로 이동 u 마지막 명령의 취소 
B 한 공백 구분 단어 뒤로 이동 U 현재 줄의 변화를 취소 
^b 한 화면 위로 스크롤 ^u 반화면을 위로 스크롤 
c 지정된 영역까지 텍스트 변경 ^V 다음 글자 해석을 방해함 
C 줄의 끝까지 텍스트 변경 w 한 단어 오른쪽으로 이동 
^c 삽입모드 끝냄(명령어 x) W 한공백 구분 단어 오른쪽으로 
d .지정된 영역까지 text삭제 ^w 전 단어 시작 위로(삽입모드) 
D 줄의 끝까지 삭제 x 현재의 문자 삭제 
^d 화면의 반을 아래로 스크롤 X 전 문자의 삭제 
e 현재 단어의 끝으로 이동 y . . . 를 yank 
E 한 공백 구분 단어 끝으로 이동 Y 현재줄을 yank 
^e 한줄 밑으로 화면 스크롤 ^y 한줄위로 화면을 스크롤 
f . . . 을 탐색 z 스크린 top위치(. mid -bot) 
F . . . 을 뒷방향으로 탐색 ZZ 저장하고 나감(=wq)

☞ 옵션 명령어
Option Default 
:set <option> <param> 
:set <nooption> <param> set명령의 취소는 <option>앞에 no를 붙힌다
:set all 현재 사용중인 vi의 옵션 지정상태에 대한 모든 것을 볼 수 있다
autoindent(ai) noai 들여 쓰기 기능 자동설정
autoprint(ap) ap 각 명령 후에 변화를 자동적으로 화면출력
autowrite(aw) noaw 여러 파일편집시 다른 파일로 이동전에 자동저장(:n, :!) 
beautify(bf) nobf 입력하는 동안 모든 제어 문자를 무시 단 tab, newline, formfeed는 제외 
directory(dir=) /tmp 버퍼를 저장하기 위한 디렉토리 이름
edcmpatible noedcmpatible ed편집기의 기능사용
errorbells(eb) errorbells 에러 발생시 벨울림
exrc(ex) noexrc home 디렉토리가 아닌곳에 .exrc화일존재 인정
hardtaps=(ht=) 8 하드웨어 텝을 위한 범위 설정
ignore case(ic) noic 검색이나 교체시 대소문자 무시
lisp nolisp indentation을 lisp형식으로 삽입
list nolist 모든탭 문자 대신 ^I, 행의 끝에 $를 표시
magic magic [*. 등의 문자들이 정규식 패턴에서 특수한 의미를 갖음
mesg masg 버퍼의 최대 크기를 설정
number(nu) nonumber 터미날로 입력되는 메시지를 가능하게 함
open noopen Vi모드를 ex에 가능하게 함
optimize(opt) optimize 
paragraphs=(para=) IPLPPQPPLIbp 문맥을 위하여 매크로 설정
prompt prompt ex명령의 prompt 설정
readonly(ro) noro ! 부호없는 화일 쓰기 방지
reraw noredraw 
remap remap map된 문자들을 반복적으로 적용
report= 5 변경을 알리기 위한 매크로 제공
scroll 1/2 스크롤할 행의 수를 설정
sections= SHNHH section을 위한 매크로를 적용
shell=(sh=) 셀 환경을 적용
shiftwith=(sw=) 지정된 줄을 오른쪽 혹은 왼쪽으로 전체를 옮기는 명령설정
showmatch(sm) {,(등을 눌린 경우 매칭되는 },)을 찾아 1초 동안 출력하고 원위치로 돌아옴
showmode noshowmode 입력 모드에서 화면의 우측하단에 "input mode"출력
slowopen(slow) tab을 눌렀을 경우 이동한 공간 설정
tabstop(ts=) 다른 화일의 tab간격이 다른 경우 
taglength(tl=) tab 화일의 내용중에 의미있는 문자수를 결정
tags= tag /usr/lib/tags 태그명령에 사용되는 화일 pass
term= 터미널 형식 지정
timeout(to) timeout 간단한 에러 메시지 출력
tty type= Set 1초 후에 매크로인 "time out"을 실행
warn warn 터미널 타입을 설정
window=(w=) 편집된 내용이 저장되지 않고 쉘 명령을 사용할 경우 경고 메시지를 출력
wrapmargin=(wm=) 0 화면상에 보여줄 행의 수를 설정
wrapscan(ws) ws 우측 마진을 설정
writeany(wa) nowa 어떠한 화일이라도 시스템이 허용하는 범위내에서 쓰기 가능
